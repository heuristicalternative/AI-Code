import os
import json
from langchain.chains import RetrievalQA
from langchain.vectorstores import FAISS
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain.llms import OpenAI
from langchain.prompts import PromptTemplate
from langchain.memory import ConversationBufferMemory
from langchain.schema import Document
from rdflib import Graph, Namespace, URIRef, Literal
from datetime import datetime
import logging
import feedparser

# Set environment variables
os.environ["OPENAI_API_KEY"] = "your_openai_api_key"

# Configure logging
logging.basicConfig(level=logging.INFO, filename='system.log', format='%(asctime)s - %(message)s')

# Ontology Namespaces
REA = Namespace("https://www.reaontology.com/schema/")
ValueFlows = Namespace("https://valueflows.github.io/valueflows/")
TaxOpt = Namespace("https://www.taxoptimization.com/schema/")

# Step 1: Dynamic Knowledge Base
class KnowledgeBase:
    def __init__(self):
        self.vector_store = None

    def build_vector_store(self, documents):
        embeddings = OpenAIEmbeddings()
        self.vector_store = FAISS.from_documents([Document(**doc) for doc in documents], embeddings)

    def add_documents(self, new_documents):
        if self.vector_store:
            self.vector_store.add_documents([Document(**doc) for doc in new_documents])
        else:
            self.build_vector_store(new_documents)

    def query(self, query):
        if not self.vector_store:
            return "Knowledge base is empty. Please add documents first."
        retriever = self.vector_store.as_retriever()
        qa = RetrievalQA.from_chain_type(
            llm=OpenAI(), retriever=retriever, return_source_documents=True
        )
        return qa.run(query)

    def fetch_rss_documents(self, url):
        feed = feedparser.parse(url)
        new_docs = [{"content": entry.summary, "metadata": {"source": entry.link}} for entry in feed.entries]
        self.add_documents(new_docs)
        logging.info("RSS feed documents added to knowledge base.")

# Step 2: Ontology Management
class OntologyManager:
    def __init__(self):
        self.graph = Graph()
        self.graph.bind("rea", REA)
        self.graph.bind("vf", ValueFlows)
        self.graph.bind("tax", TaxOpt)

    def add_entity(self, entity_type, entity_id, properties):
        entity = URIRef(f"https://example.org/{entity_type}/{entity_id}")
        for key, value in properties.items():
            self.graph.add((entity, URIRef(f"{REA}{key}"), Literal(value)))
        logging.info(f"Entity {entity_id} added to ontology.")

    def add_tax_strategy(self, strategy_id, description, jurisdiction, savings):
        effective_date = datetime.now().strftime("%Y-%m-%d")
        entity = URIRef(f"https://example.org/tax/strategy/{strategy_id}")
        self.graph.add((entity, URIRef(f"{TaxOpt}description"), Literal(description)))
        self.graph.add((entity, URIRef(f"{TaxOpt}jurisdiction"), Literal(jurisdiction)))
        self.graph.add((entity, URIRef(f"{TaxOpt}savings"), Literal(savings)))
        self.graph.add((entity, URIRef(f"{TaxOpt}effective_date"), Literal(effective_date)))
        logging.info(f"Tax optimization strategy {strategy_id} added to ontology.")

    def query_tax_strategies(self):
        results = []
        for s, p, o in self.graph.triples((None, URIRef(f"{TaxOpt}description"), None)):
            strategy = {
                "strategy_id": str(s),
                "description": str(o)
            }
            for _, prop, value in self.graph.triples((s, None, None)):
                strategy[str(prop).split("/")[-1]] = str(value)
            results.append(strategy)
        return results

# Step 3: NLP-Controlled Interactive Simulation
class DynamicIntegration:
    def __init__(self, knowledge_base, ontology_manager):
        self.knowledge_base = knowledge_base
        self.ontology_manager = ontology_manager

    def process_input(self, user_input):
        if "query knowledge" in user_input:
            query = user_input.replace("query knowledge", "").strip()
            return self.knowledge_base.query(query)

        elif "add tax strategy" in user_input:
            parts = user_input.split(",")
            if len(parts) >= 4:
                strategy_id, description, jurisdiction, savings = [p.strip() for p in parts[1:]]
                self.ontology_manager.add_tax_strategy(strategy_id, description, jurisdiction, savings)
                return "Tax strategy added successfully."
            return "Invalid input. Use format: 'add tax strategy, strategy_id, description, jurisdiction, savings'"

        elif "fetch tax strategies" in user_input:
            strategies = self.ontology_manager.query_tax_strategies()
            return json.dumps(strategies, indent=2)

        elif "fetch rss" in user_input:
            url = user_input.replace("fetch rss", "").strip()
            self.knowledge_base.fetch_rss_documents(url)
            return "RSS feed fetched and documents added."

        elif "add document" in user_input:
            content = user_input.replace("add document", "").strip()
            self.knowledge_base.add_documents([{ "content": content, "metadata": {"source": "manual input"}}])
            return "Document added successfully."

        else:
            return "Command not recognized. Try 'query knowledge', 'add tax strategy', 'fetch tax strategies', 'fetch rss', or 'add document'."

# Main Execution with Interactive Prompt
if __name__ == "__main__":
    print("Initializing Financial Pipeline Simulation...")

    # Initialize components
    kb = KnowledgeBase()
    ontology_manager = OntologyManager()
    integration = DynamicIntegration(kb, ontology_manager)

    # Initial data
    initial_documents = [
        {"content": "EU VAT rules updated for 2024", "metadata": {"source": "eu-commission"}},
        {"content": "German tax code amendments", "metadata": {"source": "germany-finance"}},
        {"content": "New tax optimization strategies in France", "metadata": {"source": "french-finance"}},
    ]
    kb.build_vector_store(initial_documents)
    print("Knowledge base initialized.")

    # Interactive loop
    print("\nCommands: 'query knowledge <query>', 'add tax strategy, id, description, jurisdiction, savings', 'fetch tax strategies', 'fetch rss <url>', 'add document <content>'")
    while True:
        user_input = input("\nEnter your command: ").strip().lower()
        if user_input in ["exit", "quit"]:
            print("Exiting simulation. Goodbye!")
            break
        response = integration.process_input(user_input)
        print(response)
